use std::{fs::File, io::BufReader};

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use bridge_core::btc::BlockHeader;
use bridge_methods::{GUEST_ELF, GUEST_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use serde_json::Value;
use bridge_core::merkle::{MerkleTree, self};
// use bridge_core::utils::char_to_digit;
use bridge_core::utils::parse_str;
use bridge_core::btc::calculate_double_sha256;
use bitcoin::hash_types::Txid;
use bitcoin::hashes::Hash;
// use bitcoin::hex::FromHex;
use bitcoin::merkle_tree::{self, PartialMerkleTree};

#[allow(non_snake_case)]
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BlockInfoExtras {
    reward: u128,
    coinbaseRaw: String,
    orphans: Vec<String>,
    medianFee: f64,
    feeRange: Vec<f64>,
    coinbaseAddress: String,
    header: String,
    // ...
    // add the fields you want
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BlockInfo {
    id: String,
    height: usize,
    version: usize,
    timestamp: u128,
    bits: u128,
    nonce: u128,
    difficulty: f64,
    merkle_root: String,
    tx_count: usize,
    size: u128,
    weight: u128,
    previousblockhash: String,
    mediantime: u128,
    stale: bool,
    extras: BlockInfoExtras,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct RpcResult {
    bestblockhash: String,
    chainwork: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct RpcInfo {
    result: RpcResult,
}

pub fn json_to_obj<T: DeserializeOwned>(file_path: &str) -> T {
    let file = File::open(file_path).expect("error");
    let reader = BufReader::new(file);
    let a: T = serde_json::from_reader(reader).expect("error");
    return a;
}

fn main() {
    env_logger::init();

    let block_info_list: Vec<BlockInfo> = json_to_obj::<Value>("./host/data/block.json")
        .as_array()
        .unwrap()
        .iter()
        .map(|block_info_value| {
            serde_json::from_value::<BlockInfo>(block_info_value.clone()).unwrap()
        })
        .collect();

    let rpc_info_list: Vec<RpcInfo> = json_to_obj::<Value>("./host/data/rpc.json")
        .as_array()
        .unwrap()
        .iter()
        .map(|rpc_info_value| serde_json::from_value::<RpcInfo>(rpc_info_value.clone()).unwrap())
        .collect();

    // assert_eq!(rpc_info_list.len() - block_info_list.len(), 1);

    let n: u32 = block_info_list.len() as u32;

    let first_chain_work: [u8; 32] = hex::decode(rpc_info_list[0].result.chainwork.clone())
        .unwrap()
        .try_into()
        .unwrap();

    let mut env = ExecutorEnv::builder();

    env.write(&n).unwrap();
    env.write(&first_chain_work).unwrap();

    // let mut env = ExecutorEnv::builder()
    //     .write(&n)
    //     .unwrap()
    //     .write(&first_chain_work)
    //     .unwrap();
    // .build()
    // .unwrap();

    for i in 0..n as usize {
        let block_header: [u8; 80] = hex::decode(block_info_list[i].extras.header.clone())
            .unwrap()
            .try_into()
            .unwrap();
        let block_header = BlockHeader::from_slice(&block_header);
        env.write(&block_header).unwrap();
    }

    let tx_info_from_json = json_to_obj::<Value>("./host/data/getblock.json");
    let tx_id_arr = tx_info_from_json["result"]["tx"].as_array().unwrap();
    
    let transactions = tx_id_arr.iter().map(|tx_id| {
        let tx_id_str = tx_id.as_str().unwrap();
        let tx_id_arr: [u8; 32] = parse_str(tx_id_str);
        tx_id_arr
    }).collect::<Vec<[u8; 32]>>();
    let merkle_tree = MerkleTree::new(12, &transactions[0..3730], 3730);

    let mut merkle_root = merkle_tree.merkle_root();
    // println!("merkle_root: {:?}", merkle_root);
    merkle_root.reverse();
    let hex_merkle_root = hex::encode(merkle_root);
    println!("hex_merkle_root: {:?}", hex_merkle_root);

    let no_of_elem_arr = merkle_tree.get_no_of_elem_arr();
    println!("no_of_elem_arr: {:?}", no_of_elem_arr);

    let tx_id_path0 = merkle_tree.get_tx_id_path(31);
    let hex_tx_id_path_idx0 = tx_id_path0.iter().map(|node| {
        let tx_id_clone = node.get_index().clone();
        tx_id_clone.to_string()
    }).collect::<Vec<String>>();
    println!("hex_tx_id_path_idx: {:?}", hex_tx_id_path_idx0);


    let tx_id_path1 = merkle_tree.get_tx_id_path(3729);
    let hex_tx_id_path1 = tx_id_path1.iter().map(|node| {
        let tx_id_clone = node.get_index().clone();
        tx_id_clone.to_string()
    }).collect::<Vec<String>>();
    println!("hex_tx_id_path: {:?}", hex_tx_id_path1);

    let tx_id_path2 = merkle_tree.get_tx_id_path(1648);
    let hex_tx_id_path2 = tx_id_path2.iter().map(|node| {
        let tx_id_clone = node.get_index().clone();
        tx_id_clone.to_string()
    }).collect::<Vec<String>>();
    println!("hex_tx_id_path: {:?}", hex_tx_id_path2);
    
    let tx_id_path3 = merkle_tree.get_tx_id_path(769);
    let hex_tx_id_path3 = tx_id_path3.iter().map(|node| {
        let tx_id_clone = node.get_index().clone();
        tx_id_clone.to_string()
    }).collect::<Vec<String>>();
    println!("hex_tx_id_path: {:?}", hex_tx_id_path3);

    let tx_id_path4 = merkle_tree.get_tx_id_path(0);
    let hex_tx_id_path4 = tx_id_path4.iter().map(|node| {
        let tx_id_clone = node.get_index().clone();
        tx_id_clone.to_string()
    }).collect::<Vec<String>>();
    println!("hex_tx_id_path: {:?}", hex_tx_id_path4);



    let test_calculate_root0 = merkle_tree.calculate_root_with_merkle_proof(merkle_tree.get_element(0, 31).get_data(), tx_id_path0);
    let test_calculate_root_str0 = hex::encode(test_calculate_root0);
    println!("test_calculate_root: {:?}", test_calculate_root_str0);

    let test_calculate_root1 = merkle_tree.calculate_root_with_merkle_proof(merkle_tree.get_element(0, 3729).get_data(), tx_id_path1);
    let test_calculate_root_str1 = hex::encode(test_calculate_root1);
    println!("test_calculate_root: {:?}", test_calculate_root_str1);

    let test_calculate_root2 = merkle_tree.calculate_root_with_merkle_proof(merkle_tree.get_element(0, 1648).get_data(), tx_id_path2);
    let test_calculate_root_str2 = hex::encode(test_calculate_root2);
    println!("test_calculate_root: {:?}", test_calculate_root_str2);

    let test_calculate_root3 = merkle_tree.calculate_root_with_merkle_proof(merkle_tree.get_element(0, 769).get_data(), tx_id_path3);
    let test_calculate_root_str3 = hex::encode(test_calculate_root3);
    println!("test_calculate_root: {:?}", test_calculate_root_str3);

    let test_calculate_root4 = merkle_tree.calculate_root_with_merkle_proof(merkle_tree.get_element(0, 0).get_data(), tx_id_path4);
    let test_calculate_root_str4 = hex::encode(test_calculate_root4);
    println!("test_calculate_root: {:?}", test_calculate_root_str4);


    let root_index = merkle_tree.get_root_index();
    let root_element = merkle_tree.get_element_from_index(root_index);
    println!("root_element: {:?}", root_element);

    let env_build = env.build().unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove_elf(env_build, GUEST_ELF).unwrap();

    let (mut output_block_hash, last_chain_work): ([u8; 32], [u8; 32]) =
        receipt.journal.decode().unwrap();

    output_block_hash.reverse();

    println!("Output: {}", hex::encode(output_block_hash));
    println!("Chain Work: {}", hex::encode(last_chain_work));

    assert_eq!(
        hex::encode(last_chain_work),
        rpc_info_list[rpc_info_list.len() - 1].result.chainwork
    );

    assert_eq!(
        hex::encode(output_block_hash),
        rpc_info_list[rpc_info_list.len() - 1].result.bestblockhash
    );

    // Optional: Verify receipt to confirm that recipients will also be able to
    // verify your receipt
    receipt.verify(GUEST_ID).unwrap();
}
