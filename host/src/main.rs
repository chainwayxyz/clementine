use std::iter;
use std::{fs::File, io::BufReader};

use bitcoin::hex::parse;
use bitcoin::script;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use bridge_core::btc::BlockHeader;
use bridge_core::merkle::{self, MerkleTree};
use bridge_methods::{GUEST_ELF, GUEST_ID};
use host::utils::json_to_obj;
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use serde_json::Value;
// use bridge_core::utils::char_to_digit;
use bridge_core::btc::calculate_double_sha256;
use bridge_core::utils::*;
// use bitcoin::hex::FromHex;
use bridge_core::tx::{Transaction, TxInput, TxOutput};

#[allow(non_snake_case)]
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BlockInfoExtras {
    reward: u128,
    coinbaseRaw: String,
    orphans: Vec<String>,
    medianFee: f64,
    feeRange: Vec<f64>,
    coinbaseAddress: String,
    header: String,
    // ...
    // add the fields you want
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BlockInfo {
    id: String,
    height: usize,
    version: usize,
    timestamp: u128,
    bits: u128,
    nonce: u128,
    difficulty: f64,
    merkle_root: String,
    tx_count: usize,
    size: u128,
    weight: u128,
    previousblockhash: String,
    mediantime: u128,
    stale: bool,
    extras: BlockInfoExtras,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct RpcResult {
    bestblockhash: String,
    chainwork: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct RpcInfo {
    result: RpcResult,
}

fn main() {
    env_logger::init();

    let block_info_list: Vec<BlockInfo> = json_to_obj::<Value>("./host/data/block.json")
        .as_array()
        .unwrap()
        .iter()
        .map(|block_info_value| {
            serde_json::from_value::<BlockInfo>(block_info_value.clone()).unwrap()
        })
        .collect();

    let rpc_info_list: Vec<RpcInfo> = json_to_obj::<Value>("./host/data/rpc.json")
        .as_array()
        .unwrap()
        .iter()
        .map(|rpc_info_value| serde_json::from_value::<RpcInfo>(rpc_info_value.clone()).unwrap())
        .collect();

    // assert_eq!(rpc_info_list.len() - block_info_list.len(), 1);

    let n: u32 = block_info_list.len() as u32;

    let first_chain_work: [u8; 32] = hex::decode(rpc_info_list[0].result.chainwork.clone())
        .unwrap()
        .try_into()
        .unwrap();

    let mut env = ExecutorEnv::builder();

    env.write(&n).unwrap();
    env.write(&first_chain_work).unwrap();

    // let merkle_tree = MerkleTree::new(3, &[[7; 32], [0; 32], [0; 32], [0; 32], [0; 32], [0; 32], [0; 32], [0; 32]], 8);

    // println!("merkle_tree: {:?}", merkle_tree);

    for i in 0..n as usize {
        let block_header: [u8; 80] = hex::decode(block_info_list[i].extras.header.clone())
            .unwrap()
            .try_into()
            .unwrap();
        let block_header = BlockHeader::from_slice(&block_header);
        env.write(&block_header).unwrap();
    }

    // let simple_tx_from_json = json_to_obj::<Value>("./host/data/simplest.json");

    // let simple_tx_version_slice = from_hex_to_bytes(simple_tx_from_json["version"].as_str().unwrap()).0;
    // let simple_tx_version = from_le_bytes_to_u32((&simple_tx_version_slice[..4]).try_into().unwrap()) as i32;
    // println!("simple_tx_version_slice: {:?}", simple_tx_version);
    // println!("simple_tx_version: {}", simple_tx_version);

    // let simple_tx_inputs_count_slice = from_hex_to_bytes(simple_tx_from_json["inputsCount"].as_str().unwrap()).0;
    // let simple_tx_inputs_count = simple_tx_inputs_count_slice[0];
    // println!("simple_tx_inputs_count: {}", simple_tx_inputs_count);

    // let simple_tx_inputs = simple_tx_from_json["inputs"].as_array().unwrap();
    // println!("simple_tx_inputs: {:?}", simple_tx_inputs);

    // let simple_tx_outputs_count_slice = from_hex_to_bytes(simple_tx_from_json["outputsCount"].as_str().unwrap()).0;
    // let simple_tx_outputs_count = simple_tx_outputs_count_slice[0];
    // println!("simple_tx_outputs_count: {}", simple_tx_outputs_count);

    // let simple_tx_outputs = simple_tx_from_json["outputs"].as_array().unwrap();
    // println!("simple_tx_outputs: {:?}", simple_tx_outputs);

    // let simple_tx_locktime_slice = from_hex_to_bytes(simple_tx_from_json["locktime"].as_str().unwrap()).0;
    // let simple_tx_locktime = from_le_bytes_to_u32((&simple_tx_locktime_slice[..4]).try_into().unwrap()) as u32;
    // println!("simple_tx_locktime_slice: {:?}", simple_tx_locktime);
    // println!("simple_tx_locktime: {}", simple_tx_locktime);

    // let new_tx_inputs = simple_tx_inputs.iter().map(|input| {
    //     let prev_tx_id = hex::decode(input["txid"].as_str().unwrap()).unwrap().try_into().unwrap();
    //     // println!("prev_tx_id: {:?}", prev_tx_id);
    //     let output_index_slice = from_hex_to_bytes(input["vout"].as_str().unwrap()).0;
    //     let output_index = from_le_bytes_to_u32((&output_index_slice[..4]).try_into().unwrap()) as u32;
    //     let script_sig_size_slice = from_hex_to_bytes(input["scriptSigSize"].as_str().unwrap()).0;
    //     let script_sig_size = script_sig_size_slice[0];
    //     let script_sig = hex::decode(input["scriptSig"].as_str().unwrap()).unwrap()[0];
    //     let mut script_sig_vec = vec![script_sig];
    //     let mut data = hex::decode(input["data"].as_str().unwrap()).unwrap();
    //     script_sig_vec.append(&mut data);
    //     for _ in 0..(256 - script_sig_vec.len()) {
    //         script_sig_vec.push(0);
    //     }
    //     // println!("SIUUUUUUUU script_sig_vec: {:?}", script_sig_vec.clone());
    //     let script_sig_array: [u8; 256] = script_sig_vec.clone()[..256].try_into().unwrap();
    //     // println!("SIUUUUUUUU script_sig_array: {:?}", script_sig_array.clone());
    //     let sequence_slice = from_hex_to_bytes(input["sequence"].as_str().unwrap()).0;
    //     let sequence = from_le_bytes_to_u32((&sequence_slice[..4]).try_into().unwrap()) as u32;
    //     TxInput::new(prev_tx_id, output_index, script_sig_size, script_sig_array.clone(), sequence)
    // }).collect::<Vec<TxInput>>();

    // println!("new_tx_inputs: {:?}", &new_tx_inputs);

    // let new_tx_outputs = simple_tx_outputs.iter().map(|output| {
    //     let value_slice = from_hex_to_bytes(output["value"].as_str().unwrap()).0;
    //     let value = from_le_bytes_to_u64((&value_slice[..8]).try_into().unwrap()) as u64;
    //     let script_pub_key_size_slice = from_hex_to_bytes(output["scriptPubKeySize"].as_str().unwrap()).0;
    //     let script_pub_key_size = script_pub_key_size_slice[0];
    //     let script_pub_key = hex::decode(output["scriptPubKey"].as_str().unwrap()).unwrap()[0];
    //     let mut script_pub_key_vec = vec![script_pub_key];
    //     let mut data = hex::decode(output["data"].as_str().unwrap()).unwrap();
    //     script_pub_key_vec.append(&mut data);
    //     let op_check_sig = hex::decode(output["OP_CHECKSIG"].as_str().unwrap()).unwrap()[0];
    //     script_pub_key_vec.push(op_check_sig);
    //     for _ in 0..(256 - script_pub_key_vec.len()) {
    //         script_pub_key_vec.push(0);
    //     }
    //     let script_pub_key_array: [u8; 256] = script_pub_key_vec.clone()[..256].try_into().unwrap();
    //     TxOutput::new(value, script_pub_key_size, script_pub_key_array)
    // }).collect::<Vec<TxOutput>>();

    // println!("new_tx_outputs: {:?}", &new_tx_outputs);

    // let simple_tx = Transaction::new(
    //     simple_tx_version as i32,
    //     simple_tx_inputs_count as u8,
    //     new_tx_inputs.try_into().unwrap(),
    //     simple_tx_outputs_count as u8,
    //     new_tx_outputs.try_into().unwrap(),
    //     simple_tx_locktime,
    // );
    // let serialized_tx = simple_tx.serialize();
    // println!("serialized_tx: {}", hex::encode(&serialized_tx.0[..serialized_tx.1]));
    // let calculated_tx_id = simple_tx.calculate_txid();
    // println!("calculated_tx_id: {}", hex::encode(calculated_tx_id));

    let parsed_tx = from_hex_to_tx("02000000000101a8326d73091a3c6dc3d29a157911870d9f946cb1ad486f6883bc43f54e32ead00100000000fffffffd192202000000000000225120ac6c0d42dc7c13ce95134b7ed720f0fb0f69e31f1207f4a4cd27b8b9d1480fe2760d000000000000225120ce3ba79938477a5a0eba08c8b4fe68164161f93e8d02c954fc2f595651c9ac3f760d0000000000002251209a878b8cea419d6c38b325b5d3d865adeda89bde1e17d7f5c5dfb9274488c796760d0000000000002251208c798a4dc26234ed0af6cf4dc8c90f81b1b4c88f122b90e40c31eafc5d9f00ae760d000000000000225120c126a9657b4812dd45c99da21896505b890bb409ccd76c2351cd095f0459a3e5760d000000000000225120b16e743dd4546e2fe8614afa277f9f8a77218ea88d3f3dd365e095688e26488a4e0d000000000000225120e45fb04347a9134c5f1ac30fd9c11009ac8f9559f449d11f904b4cfdac81734c760d000000000000225120285556f16f07443acbef4fa98e874b956aadb04962bf956953f6b2f32652c3e5760d00000000000022512048d9337cea646172991b739281b53bd2717049cf96b5480fb019769c6dc180e2760d000000000000225120f004836dadd820a173dd1b29bed0f96b81578ebc4d9baa43b7d2e80f26b8cdf4760d0000000000002251208a8279ac043405df526062f9c2981526d550ac7dc3f986146e284f321205792f4e0d0000000000002251203e4276c1e254d91e79b4f9e82dcbbe06b96d35fb20826cd5aeb570751579b20d760d00000000000022512045bf3aa1931345b852a74434fdb4f094d450445f9d1af2cf942b9116e2b4a14e4e0d000000000000225120bccea0044d4ff3281f6a6dfe3fa1f96f2c75b1b08aa6fc424c74925013cff0f4760d0000000000002251208f7ba81b13a150d6b3341bab5bb5ea9d6d73556e884d3d473d366e2f5d5357484e0d000000000000225120b98ad533806e203e570b0459d2f98a18a4702c3e72296cb7822be240a47d94a8760d00000000000022512017f92472e8785e48779e7112090e8c0554aeab93613f07c8cc72cdda0e74de26760d0000000000002251208d7b573b4ac6e71e006969a2be753fa274e90fe2ae832eb7b965324241e013b3760d00000000000022512048625337b16c988f74adb71f1dcb072f6b0ecc76cf0e7affece904dedb53b6fd760d000000000000225120737828a73e64081706a1f2da31675e772dad92ff67f9db47f5d1250b866b67c44e0d00000000000022512026a766527b603d8c825247c49bc61a8fc503f57c41fa9f7d62e2eb1d980644d5760d0000000000002251205648fdd5597d065ed69d7c0d95a0fdedeb6caf6edebfc6b23e3b8b99febdec68760d000000000000225120764451d36f7f8a14eaf9a8420928e99e50897c878c24a15a87f7a6da14450ab04e0d000000000000225120ed6f89c8aca2bba62af8931c9393dca449af32acb29fbbfaeff7ae39dd91a10a4e0d0000000000002251202c30359e80c7b7d9333158a6c3845fbba6e707ea91d50732f320f32d2b7c4cf50340a967ace5022cd301c9555a6b43370181ad4b17da4f8ba31e6b3012628aa7bff6000ee37f85906e5a2fe8e796d213576aefa20e8a67abb9acf45a76faeb584ecf5b202b819135df1275725c45f5ffa2caf64f305ccb1ab01f9269ae9720b7cbf33581ac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d380015f09fa78ef09f8fbce2808de29982efb88f2e6274636821c12b819135df1275725c45f5ffa2caf64f305ccb1ab01f9269ae9720b7cbf3358100000000");
    println!("parsed_tx: {:?}", parsed_tx);

    let parsed_tx_id = parsed_tx.calculate_txid();
    println!("parsed_tx_id: {}", hex::encode(parsed_tx_id));

    let res = parsed_tx.check_first_output_valid(
        "ac6c0d42dc7c13ce95134b7ed720f0fb0f69e31f1207f4a4cd27b8b9d1480fe2",
    );
    let first_address = parsed_tx.outputs[0].script_pub_key
        [2..parsed_tx.outputs[0].script_pub_key_size as usize]
        .to_vec();
    let test_address =
        hex::decode("ac6c0d42dc7c13ce95134b7ed720f0fb0f69e31f1207f4a4cd27b8b9d1480fe2").unwrap();
    println!("first address: {:?}", first_address);
    println!("test_address: {:?}", test_address);
    println!("res: {}", res);

    let env_build = env.build().unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove_elf(env_build, GUEST_ELF).unwrap();

    let (mut output_block_hash, last_chain_work): ([u8; 32], [u8; 32]) =
        receipt.journal.decode().unwrap();

    output_block_hash.reverse();

    println!("Output: {}", hex::encode(output_block_hash));
    println!("Chain Work: {}", hex::encode(last_chain_work));

    assert_eq!(
        hex::encode(last_chain_work),
        rpc_info_list[rpc_info_list.len() - 1].result.chainwork
    );

    assert_eq!(
        hex::encode(output_block_hash),
        rpc_info_list[rpc_info_list.len() - 1].result.bestblockhash
    );

    // Optional: Verify receipt to confirm that recipients will also be able to
    // verify your receipt
    receipt.verify(GUEST_ID).unwrap();
}
