syntax = "proto3";
package clementine;

message Empty {}

// TODO: Use this message for all txid instances
message Txid {
  bytes txid = 1;
}

message Outpoint {
  bytes txid = 1;
  uint32 vout = 2;
}

enum NormalSignatureKind {
  NormalSignatureUnknown = 0;
  // Used for TxHandlers that verifiers don't care. These will have signatures created
  // by the operator on the fly.
  OperatorSighashDefault = 1;
  Challenge = 2;
  DisproveTimeout2 = 3;
  Disprove2 = 4;
  Reimburse1 = 5;
  KickoffNotFinalized1 = 6;
  KickoffNotFinalized2 = 7;
  Reimburse2 = 8;
  NoSignature = 9;
  ChallengeTimeout2 = 10;
  MiniAssert1 = 11;
  OperatorChallengeAck1 = 12;
  NotStored = 13;
  WatchtowerChallenge1 = 14;
  YieldKickoffTxid = 15;
}

// Signatures that are needed multiple times per an operators kickoff.
// Some watchtower sigs are needed once per watchtower.
// Asserts are needed multiple times
enum NumberedSignatureKind {
  NumberedSignatureUnknown = 0;
  // Used for TxHandlers that verifiers don't care. These will have signatures created
  // by the operator on the fly.
  NumberedNotStored = 1;
  OperatorChallengeNack1 = 2;
  OperatorChallengeNack2 = 3;
  OperatorChallengeNack3 = 4;
  AssertTimeout1 = 5;
  AssertTimeout2 = 6;
  AssertTimeout3 = 7;
  UnspentKickoff1 = 8;
  UnspentKickoff2 = 9;
  WatchtowerChallengeTimeout1 = 10;
  WatchtowerChallengeTimeout2 = 11;
  WatchtowerChallenge = 12;
}

message NormalSignatureId {
  NormalSignatureKind signature_kind = 1;
}

message NumberedSignatureId {
  NumberedSignatureKind signature_kind = 1;
  int32 idx = 2;
}

// A tagged signature struct that identifies the transaction-input that the signature is for.
// The id is left as NotStored for signatures that are created on the fly by the operator (they're also not stored).
message TaggedSignature {
  oneof signature_id {
    NormalSignatureId normal_signature = 1;
    NumberedSignatureId numbered_signature = 2;
  }
  bytes signature = 3;
}

message DepositSignatures { repeated TaggedSignature signatures = 1; }

message ChallengeACKDigest {
  bytes hash = 1;
}

message WinternitzPubkey {
  repeated bytes digit_pubkey = 3;
}

message DepositParams {
  oneof deposit_data {
    BaseDeposit base_deposit = 1;
    ReplacementDeposit replacement_deposit = 2;
  }
}

message ReplacementDeposit {
  // Deposit UTXO.
  Outpoint deposit_outpoint = 1;
  // Move to vault txid that is being replaced.
  Txid old_move_txid = 2;
  // nofn public key used to sign the deposit
  bytes nofn_xonly_pk = 3;
}

// A new original deposit request's details.
message BaseDeposit {
  // User's deposit UTXO.
  Outpoint deposit_outpoint = 1;
  // User's EVM address.
  bytes evm_address = 2;
  // User's recovery taproot address.
  string recovery_taproot_address = 3;
  // nofn public key used to sign the deposit
  bytes nofn_xonly_pk = 4;
}

enum FeeType {
  UNSPECIFIED = 0;
  CPFP = 1;
  RBF = 2;
}

enum NormalTransactionId {
    UNSPECIFIED_TRANSACTION_TYPE = 0;
    ROUND = 1;
    KICKOFF = 2;
    MOVE_TO_VAULT = 3;
    PAYOUT = 4;
    CHALLENGE = 5;
    DISPROVE = 6;
    DISPROVE_TIMEOUT = 7;
    REIMBURSE = 8;
    ALL_NEEDED_FOR_DEPOSIT = 9;
    DUMMY = 10;
    READY_TO_REIMBURSE = 11;
    KICKOFF_NOT_FINALIZED = 12;
    CHALLENGE_TIMEOUT = 13;
    BURN_UNUSED_KICKOFF_CONNECTORS = 14;
    YIELD_KICKOFF_TXID = 15;
    BASE_DEPOSIT = 16;
    REPLACEMENT_DEPOSIT = 17;
}

enum NumberedTransactionType {
    UNSPECIFIED_INDEXED_TRANSACTION_TYPE = 0;
    WATCHTOWER_CHALLENGE = 1;
    OPERATOR_CHALLENGE_NACK = 2;
    OPERATOR_CHALLENGE_ACK = 3;
    ASSERT_TIMEOUT = 4;
    UNSPENT_KICKOFF = 5;
    MINI_ASSERT = 6;
    WATCHTOWER_CHALLENGE_TIMEOUT = 7;
}

message NumberedTransactionId {
  NumberedTransactionType transaction_type = 1;
  int32 index = 2;
}

message GrpcTransactionId {
  oneof id {
    NormalTransactionId normal_transaction = 1;
    NumberedTransactionId numbered_transaction = 2;
  }
}

message KickoffId {
  uint32 operator_idx = 1;
  uint32 round_idx = 2;
  uint32 kickoff_idx = 3;
}

message TransactionRequest {
  DepositParams deposit_params = 1;
  KickoffId kickoff_id = 2;
}

// Includes the deposit params and the nonce gen initial responses (pubkeys and their signatures from all verifiers)
message DepositSignSession {
  DepositParams deposit_params = 1;
  repeated NonceGenFirstResponse nonce_gen_first_responses = 2;
}

// Operator --------------------------------------------------------------------

message OperatorConfig {
  uint32 operator_idx = 1;
  Outpoint collateral_funding_outpoint = 2;
  string xonly_pk = 3;
  string wallet_reimburse_address = 4;
}

message OperatorParams {
  oneof response {
    // Operator's configuration.
    OperatorConfig operator_details = 1;
    // Winternitz pubkeys for each kickoff utxo (to commit blockhash).
    WinternitzPubkey winternitz_pubkeys = 2;
    // unspent kickoff signatures
    SchnorrSig unspent_kickoff_sig = 3;
  }
}

message OperatorKeysWithDeposit {
  OperatorKeys operator_keys = 1;
  DepositParams deposit_params = 2;
  uint32 operator_idx = 3;
}

message OperatorKeys {
  // Winternitz pubkeys for each bitvm assert tx.
  repeated WinternitzPubkey winternitz_pubkeys = 1;
  // Hashes of preimages that will be used to ACK watchtower challenges.
  repeated ChallengeACKDigest challenge_ack_digests = 2;
}

message SchnorrSig {
  bytes schnorr_sig = 1;
}

message WithdrawParams {
  // The ID of the withdrawal in Citrea
  uint32 withdrawal_id = 1;
  // User's [`bitcoin::sighash::TapSighashType::SinglePlusAnyoneCanPay`]
  // signature
  bytes input_signature = 2;
  // User's UTXO to claim the deposit
  Outpoint input_outpoint = 3;
  // The withdrawal output's script_pubkey (user's signature is only valid for this pubkey)
  bytes output_script_pubkey = 4;
  // The withdrawal output's amount (user's signature is only valid for this amount)
  uint64 output_amount = 5;
}

message WithdrawResponse {
  // The withdrawal transaction's txid
  bytes txid = 1;
}

message WithdrawalFinalizedParams {
  uint32 withdrawal_id = 1;
  Outpoint deposit_outpoint = 2;
}

message FinalizedPayoutParams {
  bytes payout_blockhash = 1;
  Outpoint deposit_outpoint = 2;
}

// An operator is responsible for paying withdrawals. It has an unique ID and
// chain of UTXOs named `round_txs`. An operator also runs a verifier. These are
// connected to the same database and both have access to watchtowers'
// winternitz pubkeys.
service ClementineOperator {
  // Returns an operator's deposit keys.
  // Deposit keys inclued Assert BitVM winternitz keys, and challenge ACK hashes.
  rpc GetDepositKeys(DepositParams) returns (OperatorKeys) {}
  // Signs all tx's it can according to given transaction type (use it with AllNeededForDeposit to get almost all tx's)
  // Creates the transactions denoted by the deposit and operator_idx, round_idx, and kickoff_idx.
  // It will create the transaction and sign it with the operator's private key and/or saved nofn signatures.
  //
  // # Parameters
  // - deposit_params: User's deposit information
  // - transaction_type: Requested Transaction type
  // - kickoff_id: Operator's kickoff ID
  //
  // # Returns
  // - Raw signed transactions that the entity can sign (no asserts and watchtower challenge)
  rpc InternalCreateSignedTxs(TransactionRequest) returns (SignedTxsWithType) {}

  // Creates all assert transactions (AssertBegin, MiniAsserts, AssertEnd), signs them, and returns the raw txs
  // in the same order.
  // # Parameters
  // - deposit_params: User's deposit information
  // - kickoff_id: Operator's kickoff ID
  // - commit_data: Commitment data for each MiniAssert tx's
  //
  // # Returns
  // - Raw signed assert transactions
  rpc InternalCreateAssertCommitmentTxs(TransactionRequest) returns (SignedTxsWithType) {}
  // Returns an operator's parameters. It will be called once, by the
  // aggregator, to set all the public keys.
  //
  // # Returns
  //
  // Returns an [`OperatorParams`], which includes operator's configuration and
  // Watchtower parameters.
  rpc GetParams(Empty) returns (stream OperatorParams) {}

  // Signs everything that includes Operator's burn connector.
  //
  // # Parameters
  //
  // - User's deposit information
  // - Nonce metadata
  //
  // # Returns
  //
  // - Operator burn Schnorr signature
  rpc DepositSign(DepositSignSession) returns (stream SchnorrSig) {}

  // Prepares a withdrawal if it's profitable and previous sequential_collateral_tx's timelock
  // has ended, by paying for the withdrawal and locking the current sequential_collateral_tx.
  rpc Withdraw(WithdrawParams)
    returns (WithdrawResponse) {}

  // Checks if a withdrawal is finalized.
  //
  // Steps:
  //
  // 1. Calculate move_txid and check if the withdrawal idx matches it
  // 2. Check if it is proved on citrea
  // 3. Send operator_take_txs
  //
  // # Parameters
  //
  // - withdrawal_id: Withdrawal's ID
  // - deposit_outpoint: Withdrawal's deposit UTXO
  rpc WithdrawalFinalized(WithdrawalFinalizedParams) returns (Empty) {}


  rpc InternalFinalizedPayout(FinalizedPayoutParams) returns (Txid) {}

  rpc InternalEndRound(Empty) returns (Empty) {}
}

// Verifier --------------------------------------------------------------------

message VerifierParams {
  uint32 id = 1;
  bytes public_key = 2;
  uint32 num_verifiers = 3;
  uint32 num_watchtowers = 4;
  uint32 num_operators = 5;
  uint32 num_round_txs = 6;
}

message PartialSig {
  bytes partial_sig = 1;
}

message NonceGenRequest {
  uint32 num_nonces = 1;
}

message NonceGenFirstResponse {
  // ID of the nonce session (used to store nonces in verifier's memory)
  uint32 id = 1;
  // Number of nonces to generate
  uint32 num_nonces = 2;
}
message NonceGenResponse {
  oneof response {
    NonceGenFirstResponse first_response = 1;
    bytes pub_nonce = 2;
  }
}

message VerifierDepositSignParams {
  oneof params {
    DepositSignSession deposit_sign_first_param = 1;
    bytes agg_nonce = 2;
  }
}

message VerifierDepositFinalizeParams {
  oneof params {
    DepositSignSession deposit_sign_first_param = 1;
    bytes schnorr_sig = 2;
    bytes move_tx_agg_nonce = 3;
  }
}

message VerifierPublicKeys {
  repeated bytes verifier_public_keys = 1;
}

service ClementineVerifier {
  // Sets the operator's winternitz keys and challenge ACK hashes and saves them into the db.
  rpc SetOperatorKeys(OperatorKeysWithDeposit)  returns (Empty) {}
  // Signs all tx's it can according to given transaction type (use it with AllNeededForDeposit to get almost all tx's)
  // Creates the transactions denoted by the deposit and operator_idx, round_idx, and kickoff_idx.
  // It will create the transaction and sign it with the operator's private key and/or saved nofn signatures.
  //
  // # Parameters
  // - deposit_params: User's deposit information
  // - transaction_type: Requested Transaction type
  // - kickoff_id: Operator's kickoff ID
  //
  // # Returns
  // - Raw signed transactions that the entity can sign (no asserts and watchtower challenge)
  rpc InternalCreateSignedTxs(TransactionRequest) returns (SignedTxsWithType) {}
  // Returns verifiers' metadata. Needs to be called once per setup.
  rpc GetParams(Empty) returns (VerifierParams) {}

  // Saves all verifiers public keys.
  rpc SetVerifiers(VerifierPublicKeys) returns (Empty) {}

  // Saves an operator.
  rpc SetOperator(stream OperatorParams) returns (Empty) {}

  // Saves a watchtower.
  rpc SetWatchtower(stream WatchtowerParams) returns (Empty) {}

  // Generates nonces for a deposit.
  //
  // # Returns
  //
  // Nonce metadata followed by nonces.
  rpc NonceGen(NonceGenRequest) returns (stream NonceGenResponse) {}

  // Signs deposit with given aggNonces and it's corresponding secNonce using
  // nonce_id.
  rpc DepositSign(stream VerifierDepositSignParams)
    returns (stream PartialSig) {}

  // Verifies every signature and signs move_tx.
  rpc DepositFinalize(stream VerifierDepositFinalizeParams)
    returns (PartialSig) {}

  // Checks if the kickoff tx is malicious and if so, try to send all necessary txs to punish the operator
  rpc InternalHandleKickoff(Txid) returns (Empty) {}
}

// Watchtower ------------------------------------------------------------------

message WatchtowerParams {
  oneof response {
    uint32 watchtower_id = 1;
    // xonly public key serialized to bytes
    bytes xonly_pk = 2;
  }
}

// Watchtowers are responsible for challenging the operator's kickoff txs.
// Each watchtower also runs a verifier server connected to the same db. Thus,
// they will have the operator's winternitz pubkeys.
service ClementineWatchtower {
  // Creates a transaction denoted by the deposit and operator_idx, round_idx, and kickoff_idx.
  // It will create the transaction(needs to only sign Watchtower Challenge TX) and sign it with watchtowers's winternitzk keys.
  //
  // # Parameters
  // - deposit_params: User's deposit information
  // - transaction_type: Requested Transaction type
  // - kickoff_id: Operator's kickoff ID
  //
  // # Returns
  // - Raw signed transaction
  rpc InternalCreateWatchtowerChallenge(TransactionRequest) returns (SignedTxWithType) {}
  // Returns every operator's winternitz public keys.
  rpc GetParams(Empty) returns (stream WatchtowerParams) {}
}

// Aggregator ------------------------------------------------------------------

message RawSignedTx {
  bytes raw_tx = 1;
}

message SendTxRequest {
  RawSignedTx raw_tx = 1;
  FeeType fee_type = 2;
}

message RawSignedTxs {
  repeated RawSignedTx raw_txs = 1;
}

message SignedTxWithType {
  GrpcTransactionId transaction_type = 1;
  bytes raw_tx = 2;
}

message SignedTxsWithType {
  repeated SignedTxWithType signed_txs = 1;
}

service ClementineAggregator {
  // Sets up the system of verifiers, watchtowers and operators by:
  // 1. Collecting verifier keys, then distributing all verifier keys to all verifiers
  // 2. Collecting all operator configs, and distributing them to all verifiers
  // 3. Collecting all possible Winternitz pubkeys (determined by operator idx, seqcol idx, kickoff idx) from watchtowers, and distributing to verifiers.
  rpc Setup(Empty) returns (Empty) {}
  // This will call, DepositNonceGen for every verifier,
  // then it will aggregate one by one and then send it to DepositSign,
  // then it will aggregate the partial sigs and send it to DepositFinalize,
  // this will also call the operator to get their signatures and send it to
  // DepositFinalize then it will collect the partial sigs and create the move
  // tx.
  rpc NewDeposit(DepositParams) returns (Txid) {}
  // send a pre-signed tx
  rpc InternalSendTx(SendTxRequest) returns (Empty) {}
}
